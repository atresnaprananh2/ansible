- name: Configure SRU 80 IPS repository on Solaris
  hosts: ipssvr
  gather_facts: true
  become: true
  remote_user: root
  become_user: root
  vars:
    - destdownload: "/opt/opsware"
    - ansible_python_interpreter: "/opt/opsware/agent/bin/python3"
    - publisher_name: solaris
    
  tasks:
    # - name: check the SA solpatch import output for the server
    #   ansible.builtin.command: /opt/opsware/solpatch_import/bin/solpatch_import -a show --filter="rec,server={{ ansible_facts.hostname }}"
    #   register: chkoutput

    - name: Preparation - Get Software Policy Attr
      shell: |
        ./python3 - << 'EOF'
        import pytwist
        from pytwist import * 
        from pytwist.com.opsware.search import Filter
        from pytwist import twistserver
        from pytwist.com.opsware.server import ServerRef
        import json
        ts = pytwist.twistserver.TwistServer()
        try:
            server_service = ts.server.ServerService
            filter = Filter()
            server_refs = server_service.findServerRefs(filter)
            for server_ref in server_refs:
                server_details = ts.server.ServerService.getServerVO(server_ref)
                if server_details.primaryIP == "{{ ansible_facts['default_ipv4']['address'] }}" :
                    try:
                        print(ts.server.ServerService.getCustAttrs(server_ref, None, True) )
                    except Exception as e:
                        print(f"Error processing server {server_ref.getId()}: {e}")
          
        except Exception as e:
            print(f"Failed to authenticate: {str(e)}")
            exit(1)  
        EOF
      register: instattr
      args:
        chdir: '/opt/opsware/agent/bin'
      when: "'RedHat' in ansible_distribution or 'Solaris' in ansible_distribution"
    
    - name:  Preparation - setcustattr
      set_fact:
        custattr: "{{ instattr.stdout }}"
      when: "'Solaris' in ansible_distribution"
    
    - name:  Preparation - set variables
      set_fact:
        sacoreid: "{{ custattr.sru_sacoreid }}"
        srudir: "{{ custattr.sru_ipsdir }}"
        custom_repo_uri: "file:///{{ custattr.sru_ipsdir }}"

    

    - name: set software policy from SACore
      shell: "{{ ansible_python_interpreter }} -"
      args:
        stdin: |
          from pytwist.com.opsware.job import JobRef
          import time
          from pytwist import twistserver
          from pytwist.com.opsware.script import ServerScriptJobArgs
          from pytwist.com.opsware.server import ServerRef

          # Authenticate to the TwistServer
          ts = twistserver.TwistServer()
          ts.authenticate("admin", "opsware_admin")

          # Set up script execution arguments
          args = ServerScriptJobArgs()
          args.targets = [ServerRef({{ sacoreid }})]

          args.tailOutputSize = 10 * 1024  # Capture last 10 KB of output
          args.timeOut = 7200    # Timeout after 2 hrs

          userTag = "adHoc SHELL script"

          # Shell script path to execute
          source = """/opt/opsware/solpatch_import/bin/solpatch_import -a policy --policy_path='/Opsware/Tools/ipspolicy{{ ansible_facts.hostname }}' --filter='rec,server={{ ansible_facts.hostname }}'"""

          codeType = 'SH'

          # Execute the script via OpenText Server Automation
          jobRef = ts.script.ServerScriptService.startAdhocServerScript(source, codeType, args, userTag, None, None)

          print(f"Created job {jobRef.getId()}, waiting for completion...")

          # Wait until the job completes
          max_wait_time = 7200 
          start_time = time.time()

          while True:
              try:
                  job_info = ts.job.JobService.getJobInfoVO(JobRef(jobRef.getId()))
                  if job_info is None:
                      print(f"Failed to retrieve job info for {jobRef.getId()}. Exiting loop.")
                      break

                  if job_info.status in [2, 3, 4, 6]:  # Completed, Failed, or Canceled
                      print(f"Job {jobRef.getId()} finished with status: {job_info.status}")
                      break

                  print(f"Job {jobRef.getId()} is still running (status={job_info.status})...")

              except Exception as e:
                  print(f"Error retrieving job info: {e}")
                  break

              if time.time() - start_time > max_wait_time:
                  print(f"Timeout reached while waiting for job {jobRef.getId()}. Exiting loop.")
                  break

              time.sleep(10)
      register: resultjob

    - name: debug result
      debug:
        var: resultjob

    

    - name: Get IPS policy package list as JSON
      command: "{{ ansible_python_interpreter }}"
      args:
        stdin: |
          from pytwist import *
          from pytwist.com.opsware.swmgmt import *
          from pytwist.com.opsware.pkg import *
          from pytwist.com.opsware.search import Filter
          import json
          import urllib.parse


          ts = twistserver.TwistServer()
          ts.authenticate("admin", "opsware_admin")

          SoftwarePolicyService = ts.swmgmt.SoftwarePolicyService
          PatchPolicyService = ts.swmgmt.PatchPolicyService
          server_service = ts.server.ServerService
          policy_name = "ipspolicy{{ansible_facts.hostname}}"

          policylist = SoftwarePolicyService.findSoftwarePolicyRefs(Filter())
          servers = server_service.findServerRefs(Filter())
          packages = []

          for pol in policylist:
              policy_vos = SoftwarePolicyService.getSoftwarePolicyVO(pol)
              if policy_vos.name == policy_name:
                  print(policy_vos.name + "-" + str(policy_vos.ref.id))
                  for srv in servers:
                      server_vo = server_service.getServerVO(srv)
                      if server_vo.primaryIP == "{{ ansible_facts['default_ipv4']['address'] }}":
                          print(server_vo.mid)
                          for i in range(len(policy_vos.installableItemData)):
                              encoded = urllib.parse.quote(f"pkg:///{policy_vos.installableItemData[i].policyItem.name}", safe='') + ".p5p"
                              package = {
                                  "file_name": encoded,
                                  "object_id": policy_vos.installableItemData[i].policyItem.id
                              }
                              packages.append(package)
                          break
                  break

          json_output = json.dumps(packages, indent=2)
          print(json.dumps(packages))
      register: policy_output
      tags: download,remote

    - name: chk val 3
      debug:
        var: policy_output.stdout
    
    - name: Split stdout lines and extract JSON block
      set_fact:
        policy_lines: "{{ policy_output.stdout_lines }}"
    - name: Split stdout lines and extract JSON block
      set_fact:
        patch_list: "{{ policy_lines[2] | from_json }}"

    - name: chk val 3
      debug:
        var: patch_list


    - name: Ensure patch dir temp exist
      file:
        path: /tmp/SRUPatch
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Download patch files using Tsunami
      command: "{{ ansible_python_interpreter }}"
      args:
        stdin: >
          from coglib import downloader;

          downloader.Tsunami().fetch_unit(
            downloader.DownloadUnit({{ item.object_id }}, None, None, '{{ item.file_name }}', None, '/tmp/SRUPatch')
          )
      loop: "{{ patch_list }}"
      ignore_errors: yes

    - name: Remove existing publisher '{{ publisher_name }}'
      shell: |
        pkg unset-publisher {{ publisher_name }}
      register: unset_pub
      failed_when: unset_pub.rc != 0 and 'Unable to unset publisher' not in unset_pub.stderr
      changed_when: "'Removed' in unset_pub.stdout or 'Removed' in unset_pub.stderr"
      ignore_errors: true
    
    - name: Ensure .p5p patch files exist in /tmp/SRUPatch
      find:
        paths: /tmp/SRUPatch
        patterns: "*.p5p"
      register: p5p_files

    - name: Fail if no patch files are found
      fail:
        msg: "No .p5p patch files found in {{ patch_source_dir }}"
      when: p5p_files.matched == 0

    - name: Ensure custom repo directory exists
      file:
        path: "{{ srudir }}"
        state: directory
        mode: '0755'

    - name: Create the IPS repo if not already present
      command: pkgrepo create {{ srudir }}
      args:
        creates: "{{ srudir }}/pkg5.repository"

    - name: Import each patch package into custom IPS repo
      shell: >
        pkgrecv -s "{{ item.path }}" -d "{{ srudir }}" '*'
      loop: "{{ p5p_files.files }}"
      loop_control:
        label: "{{ item.path }}"

    - name: Set publisher to custom IPS repo path
      shell: |
        pkg set-publisher -g "{{ custom_repo_uri }}" {{ publisher_name }}
      register: setpub

    - name: Verify publisher setting
      command: pkg publisher
      register: pub_status

    - debug:
        var: pub_status.stdout_lines

    - name: "Final --- Remove the temp patch dir"
      file:
        path: '/tmp/SRUPatch'
        state: absent

    

    
    # - name: Decode and rename all encoded .p5p files in a directory
    #   shell: |
    #     /opt/opsware/agent/bin/python3 -c "
    #     import os, urllib.parse

    #     for fname in os.listdir('.'):
    #         if fname.endswith('.p5p') and '%' in fname:
    #             decoded = urllib.parse.unquote(fname)
    #             clean_name = os.path.basename(decoded).split('/')[-1]
    #             print(f'Renaming {fname} -> {clean_name}')
    #             os.rename(fname, clean_name)
    #     "
    #   args:
    #     chdir: /tmp/SRUPatch

    # - name: Get list of package files
    #   find:
    #     paths: /tmp/SRUPatch
    #     patterns: "*.p5p"
    #   register: pkg_files
    
    # - name: Import each .p5p file into local IPS repo
    #   shell: |
    #     pkgrecv -s "{{ item.path }}" -d {{ srudir }} '*'
    #   loop: "{{ pkg_files.files }}"
    #   loop_control:
    #     label: "{{ item.path }}"
    
    # - name: "Final --- Remove the temp patch dir"
    #   file:
    #     path: '/tmp/SRUPatch'
    #     state: absent

    
   
    